#!/usr/bin/env ruby

TT_NAMES = {3 => "MRB_TT_FIXNUM", 6 => "MRB_TT_FLOAT", 16 => "MRB_TT_STRING"}

def extract_binary(file)
  start = false
  data = ""
  open(file).each_line {|line|
    if(start)
      last = false
      b = line.sub(/}.*$/) { last = true; "" }.split(",").map {|v| v.strip }
      b.delete("")
      b.map! {|v| v.hex }
      data += b.pack("C*")
      break if last
    elsif(line =~ /^\s*const\s+(uint8_t|alt_u8)\s+\w+\s*\[\s*\]\s*=\s*{\s*$/)
      start = true
    end
  }
  data
end

def dumpmrb(file)
  if(file =~ /\.c$/)
    data = extract_binary(file)
  else
    data = open(file, "rb").read
  end

  puts("\"#{file}\":")
  puts("  binary_identify:  #{data.slice!(0, 4).inspect}")
  puts("  binary_version:   #{data.slice!(0, 4).inspect}")
  puts("  binary_crc:       0x%04x" % data.slice!(0, 2).unpack("n").first)
  puts("  binary_size:      0x%08x" % data.slice!(0, 4).unpack("N").first)
  puts("  compiler_name:    #{data.slice!(0, 4).inspect}")
  puts("  compiler_version: #{data.slice!(0, 4).inspect}")

  indexes = {}

  while(true)
    puts("  -")
    secid = data.slice!(0, 4)
    secsz, = data.slice!(0, 4).unpack("N")
    puts("    section_identify: #{secid.inspect}")
    puts("    section_size: 0x%08x\n" % secsz)
    break if secid == "END\0"
    sdata = data.slice!(0, secsz - 8)
    if(sdata.size < (secsz - 8))
      puts("    # section data is missing (actual %d bytes)" % (sdata.size + 8))
      break
    end
    indexes[secid] ||= 0
    puts("    index: %d" % indexes[secid])
    indexes[secid] += 1
    if(secid == "IREP")
      puts("    rite_version: #{sdata.slice!(0, 4).inspect}")
      nirep,sirep = sdata.slice!(0, 4).unpack("n2")
      puts("    nirep: %d" % nirep)
      puts("    sirep: %d" % sirep)
      recsz, = sdata.slice!(0, 4).unpack("N")
      nlocals,nregs = sdata.slice!(0, 4).unpack("n2")
      puts("    record_size: 0x%08x" % recsz)
      puts("    # record_size does not match") if recsz != sdata.size
      puts("    nlocals: %d" % nlocals)
      puts("    nregs: %d" % nregs)
      ilen, = sdata.slice!(0, 4).unpack("N")
      puts("    ilen: %d" % ilen)
      puts("    iseq: [")
      i = ilen
      n = 6
      while(i > 0)
        t = sdata.slice!(0, 4*[n,i].min).unpack("N*").map {|v| "0x%08x" % v}.join(", ")
        i -= n
        t += "," if i > 0
        puts("      #{t}")
      end
      puts("    ]")
      plen, = sdata.slice!(0, 4).unpack("N")
      puts("    plen: %d" % plen)
      puts("    pool:") if plen > 0
      plen.times {|n|
        tt,len = sdata.slice!(0, 3).unpack("Cn")
        v = sdata.slice!(0, len)
        puts("      - # %d" % n)
        puts("        type: #{TT_NAMES[tt]}")
        puts("        len: %d" % len)
        puts("        str: #{v.inspect}")
        sdata.slice!(0, 1)
      }
      slen, = sdata.slice!(0, 4).unpack("N")
      puts("    slen: %d" % slen)
      puts("    syms:") if slen > 0
      slen.times {|n|
        len, = sdata.slice!(0, 2).unpack("n")
        if(len < 0xffff)
          v = sdata.slice!(0, len)
          puts("      - %-16s # %d" % [v.inspect, n])
          sdata.slice!(0, 1)
        else
          puts("      # %-16s # %d" % ["(dummy)", n])
        end
      }
    elsif(secid == "LINE")
      nirep,sirep = sdata.slice!(0, 4).unpack("n2")
      puts("    nirep: %d" % nirep)
      puts("    sirep: %d" % sirep)
      puts("    # line section decoding is not supported yet")
    else
      puts("    # unknown section type")
    end
  end
  puts("  # junk data found (%d bytes)" % data.size) if data.size > 0
  puts
end

ARGV.each {|f| dumpmrb(f) }

